// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     cpp_templates/function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>

namespace sym {

/**
 * This function was autogenerated. Do not modify by hand.
 *
 * Args:
 *     x0: Scalar
 *     x1: Scalar
 *
 * Outputs:
 *     result: Matrix7_7
 *
 */
template <typename Scalar>
Eigen::SparseMatrix<Scalar> B1SsComputeB(const Scalar x0, const Scalar x1) {
  // Total ops: 13

  // Input arrays

  // Intermediate terms (3)
  const Scalar _tmp0 = x1 + 2;
  const Scalar _tmp1 = -x0 + x1;
  const Scalar _tmp2 = x0 + 1;

  // Output terms (1)
  static constexpr int kRows_result = 7;
  static constexpr int kCols_result = 7;
  static constexpr int kNumNonZero_result = 15;
  static constexpr int kColPtrs_result[] = {0, 3, 5, 7, 9, 11, 13, 15};
  static constexpr int kRowIndices_result[] = {4, 5, 6, 0, 1, 0, 2, 0, 3, 1, 4, 2, 5, 3, 6};
  Scalar result_empty_value_ptr[15];
  Eigen::SparseMatrix<Scalar> result = Eigen::Map<const Eigen::SparseMatrix<Scalar>>(
      kRows_result, kCols_result, kNumNonZero_result, kColPtrs_result, kRowIndices_result,
      result_empty_value_ptr);
  Scalar* result_value_ptr = result.valuePtr();

  result_value_ptr[0] = _tmp0 * x0;
  result_value_ptr[1] = _tmp0 - x0;
  result_value_ptr[2] = _tmp1;
  result_value_ptr[3] = _tmp2 + x1;
  result_value_ptr[4] = 1 - x0;
  result_value_ptr[5] = x1;
  result_value_ptr[6] = -4;
  result_value_ptr[7] = Scalar(-1.0);
  result_value_ptr[8] = 2;
  result_value_ptr[9] = 2;
  result_value_ptr[10] = -_tmp2;
  result_value_ptr[11] = _tmp1;
  result_value_ptr[12] = -1;
  result_value_ptr[13] = -4;
  result_value_ptr[14] = -x0 - x1;

  return result;
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
