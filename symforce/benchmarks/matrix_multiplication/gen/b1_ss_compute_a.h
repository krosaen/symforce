// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     cpp_templates/function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>

namespace sym {

/**
 * This function was autogenerated. Do not modify by hand.
 *
 * Args:
 *     x0: Scalar
 *     x1: Scalar
 *
 * Outputs:
 *     result: Matrix7_7
 *
 */
template <typename Scalar>
Eigen::SparseMatrix<Scalar> B1SsComputeA(const Scalar x0, const Scalar x1) {
  // Total ops: 12

  // Input arrays

  // Intermediate terms (0)

  // Output terms (1)
  static constexpr int kRows_result = 7;
  static constexpr int kCols_result = 7;
  static constexpr int kNumNonZero_result = 14;
  static constexpr int kColPtrs_result[] = {0, 3, 5, 7, 9, 10, 12, 14};
  static constexpr int kRowIndices_result[] = {4, 5, 6, 0, 1, 0, 2, 0, 3, 1, 2, 5, 3, 6};
  Scalar result_empty_value_ptr[14];
  Eigen::SparseMatrix<Scalar> result = Eigen::Map<const Eigen::SparseMatrix<Scalar>>(
      kRows_result, kCols_result, kNumNonZero_result, kColPtrs_result, kRowIndices_result,
      result_empty_value_ptr);
  Scalar* result_value_ptr = result.valuePtr();

  result_value_ptr[0] = -1;
  result_value_ptr[1] = -3;
  result_value_ptr[2] = 1 - x0;
  result_value_ptr[3] = -1;
  result_value_ptr[4] = -1;
  result_value_ptr[5] = 1;
  result_value_ptr[6] = x1 + 3;
  result_value_ptr[7] = 2 * x0;
  result_value_ptr[8] = -x1 - 2;
  result_value_ptr[9] = (Scalar(1) / Scalar(2)) * x1;
  result_value_ptr[10] = -1;
  result_value_ptr[11] = Scalar(1.0);
  result_value_ptr[12] = -4;
  result_value_ptr[13] = Scalar(-1.0);

  return result;
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
